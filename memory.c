#include "pch.h"
#include "fdc.h"
#include "keyboard.h"

#define BASE_MEMORY_SIZE  0x8000
#define VIDEO_BUFFER_SIZE 0x1000

byte g_byMemory[BASE_MEMORY_SIZE];
byte g_byVideoMemory[VIDEO_BUFFER_SIZE];
word g_wVideoStart;
word g_wVideoEnd;
byte g_byVideoNumCols;
byte g_byVideoNumRows;
int  g_nVideoModified;

byte  g_byModel1_RtcIntr;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INT* activated by
//   - INTRQ of FDC passed through gates and flip flop
//   - RTC drives INT* low every 25ms (40Hz)
//   - Reading from FDC status register (0x37EC) clears the FDC INTRQ
//   - Reading from 0x37E0 clears the interrupt latch (Z28)
// 
// 0x37E8 - Read  - Printer port status
// 0x37E8 - Write - Printer port data bus
// 
// 0x37E0 - Read resets the interrupt latch
//          Read D7 = 1 => interrupt generated by RTC
//                  = 0 => generated by FDC
//
// 0x37E0 - Read (D6 - INTRQ pin, D7 counter?
// 0x37E0 - Write - Drive select
// 
// 0x37EC - Cmd/Status register
// 0x37ED - Track register
// 0x37EE - Sector register
// 0x37EF - Data register
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Model1_RtcIntr()
{
  g_byModel1_RtcIntr = 1;
//  cpu.intr = 1;
}

byte Model1_MemRead(word addr)
{
	switch (addr)
	{
		case 0x37E0:
		case 0x37E1:
		case 0x37E2:
		case 0x37E3:
			g_byMemory[addr] = 0x3F;
      
			if (g_FDC.stStatus.byIntrRequest)
			{
					g_byMemory[addr] |= 0x40;
			}

			if (g_byModel1_RtcIntr)
			{
				g_byMemory[addr] |= 0x80;
				g_byModel1_RtcIntr = 0;
			}

			break;

		case 0x37EC: // Cmd/Status register
		case 0x37ED: // Track register
		case 0x37EE: // Sector register
		case 0x37EF: // Data register
			g_byMemory[addr] = fdc_read(addr);
			break;

		default:
			break;
	}

  return g_byMemory[addr];
}

void Model1_MemWrite(word addr, byte by)
{
	switch (addr)
	{
		case 0x37E0:
		case 0x37E1:
		case 0x37E2:
		case 0x37E3: // drive select
			fdc_write_drive_select(by);
			break;

		case 0x37EC: // Cmd/Status register
		case 0x37ED: // Track register
		case 0x37EE: // Sector register
		case 0x37EF: // Data register
			fdc_write(addr, by);
			break;
	}

	if ((addr >= g_wVideoStart) && (addr <= g_wVideoEnd))
	{
		g_byVideoMemory[addr-g_wVideoStart] = by;
		++g_nVideoModified;
	}

	g_byMemory[addr] = by;
}

void Model1_Init(void)
{
	int i;

//	memset(g_byMemory, 0x00, sizeof(g_byMemory));

//	g_nModel1_ROM_Size = MODEL1_ROM_SIZE;

//	for (i = 0; i < g_nModel1_ROM_Size; ++i)
//	{
//		g_byMemory[i] = g_byModel1_ROM[i];
//	}

//	memset(g_byVideoMemory, 0x20, sizeof(g_byVideoMemory));
	g_wVideoStart       = 0x3C00;
	g_wVideoEnd         = 0x3FFF;
	g_byVideoNumCols    = 64;
	g_byVideoNumRows    = 16;
	g_nVideoModified    = 0;
//	g_wKeyboardStart    = 0x3800;
//	g_wKeyboardEnd      = 0x3BFF;
  //	g_byKeyboardMode    = eKeyMemoryMapped;

	g_FDC.byNmiMaskReg  = 0x80;
	g_byModel1_RtcIntr  = 0;
	g_byMemory[0x37EC]  = FdcGetStatus();
	g_byMemory[0x37ED]  = g_FDC.byTrack;
	g_byMemory[0x37EE]  = g_FDC.bySector;
	g_byMemory[0x37EF]  = g_FDC.byData;
}
